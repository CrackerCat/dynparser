= DynParser


A small and simple Dynamic Parser




== Usage

Add to `cargo.toml`
[source, toml]
----
[dependencies]
pending...
----

See example below



== Modifs

0.1.0  First version


== Input

=== Grammar

The grammar is indentation sensitive.

You can check de indentation special cases in https://github.com/jleahred/indentation_flattener[indentation_flattener]


==== Rule elements enumeration

Examples below

[horizontal]
`=`:: On left, symbol, on right expresion defining symbol
`symbol`:: On right, it's an string without quotes
`.`:: Any char
`"..."`:: Literal delimited by quotes
`space`:: Rule concatenation (and operation)
`/`:: Or operation
`(...)`:: A expression composed of sub expresions
`?`:: One optional
`*`:: Repeat 0 or more
`+`:: Repeat 1 or more
`!`:: negate expression
`[...]`:: Match chars. It's a list or ranges (or both)
`->`:: pending...
`:`:: pending...

Let's see by example

A simple literal string.

.Literal
[source, peg]
----
main = "Hello world"
----

.Concatenation (and)
[source, peg]
----
main = "Hello "  "world"
----


Referencing symbols

.Symbol
[source, peg]
----
main = hi
hi   = "Hello world"
----

Or conditions `/`
.Or
[source, peg]
----
main = "hello" / "hi"
----

.Or multiline
[source, peg]
----
main
    = "hello"
    / "hi"
----

.Or disorganized
[source, peg]
----
main = "hello"
     / "hi" / "hola"
----


.Parenthesis
[source, peg]
----
main = ("hello" / "hi")  " world"
----


Just multiline

.Multiline1
[source, peg]
----
main
    = ("hello" / "hi")  " world"
----

.Multiline2
[source, peg]
----
main
    = ("hello" / "hi")
    " world"
----

It is recomended to use or operator `/` on each new line and `=` kept on first line, like


.Multiline organized
[source, peg]
----
main = ("hello" / "hi")  " world"
     / "bye"
----

.One optional
[source, peg]
----
main = ("hello" / "hi")  " world"?
----


.Repetitions
[source, peg]
----
main = one_or_more_a / zero_or_many_b
one_or_more = "a"+
zero_or_many = "b"*
----

Negation will not move current possition

Next example is consume till get an "a"

.Negation
[source, peg]
----
main = (!"a" .)*
----

.Consume till
[source, peg]
----
main    = comment*
comment = "//" (!"\n" .)*
        / "/*" (!"*/" .)* "*/"
----

Match a set of chars.
Chars can be defined by range.


.Match chars
[source, peg]
----
number  = digit+ ("." digit+)?
digit   = [0-9]
a_or_b  = [ab]
id      = [_a-zA-Z][_a-zA-Z0-9]*
a_or_b_or_digit  = [ab0-9]
----


Simple recursion
.one or more "a" recursive
[source, peg]
----
as  = "a" as
    / "a"

//  simplified with `+`
ak = "a"+
----



Recursion to match parenthesis

.Recursion match par
[source, peg]
----
match_par = "(" match_par ")"
          / "(" ")"
----




Grammar pending...


=== Text

Hey, I'm a text parser, I need a text to parse ;-P

If you want to parse text indentation sensitive, I recomend you the lib
https://github.com/jleahred/indentation_flattener[indentation_flattener]

In fact, as you saw before, I work with a grammar indented sensitive and I use this library.

The only consideration about the text to parse, is the type. It's not a generic String, it has to be
a more concrete `Text2Parse`

[source, rust]
----
#[derive(Debug, PartialEq, Default)]
pub struct Text2Parse(pub String);
----



== Output

AST

pending...



== API

It works with concrete types vs general types (reducing use of types like String, u32 or usize)


Constants::
[source, rust]
----
pending
----


Concrete types::
[source, rust]
----
pending
----


Functions to call::
[source, rust]
----
pending
----



Error type::
[source, rust]
----
pending
----


Thats all


Look into lib.rs


== Examples

You can look into tests.rs.


.Simple example
[source, rust]
----
pending...
----



.Complex example
[source, rust]
----
pending...
----

More examples on tests.rs


== Hacking the code


[source, rust]
----
type Rules = HashMap<Symbol, Expression>;
----
