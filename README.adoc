= DynParser


A small and simple Dynamic Parser




== Usage

Add to `cargo.toml`
[source, toml]
----
[dependencies]
pending...
----

See examples below



== Modifs

0.1.0  First version


== Input

=== Grammar

pending... The grammar is indentation sensitive.

pending... You can check de indentation special cases in https://github.com/jleahred/indentation_flattener[indentation_flattener]

pending... It doesn't look necessary to work with indentation on Grammar



==== Rule elements enumeration

Examples below

[horizontal]
`=`:: On left, symbol, on right expresion defining symbol
`symbol`:: On right, it's an string without quotes
`.`:: Any char
`"..."`:: Literal delimited by quotes
`space`:: Separate tokens and Rule concatenation (and operation)
`/`:: Or operation
`(...)`:: A expression composed of sub expresions
`?`:: One optional
`*`:: Repeat 0 or more
`+`:: Repeat 1 or more
`!`:: negate expression
`[...]`:: Match chars. It's a list or ranges (or both)
`->`:: pending...
`:`:: pending...

Let's see by example

A simple literal string.

.Literal
[source, peg]
----
main = "Hello world"
----

.Concatenation (and)
[source, peg]
----
main = "Hello "  "world"
----


Referencing symbols

.Symbol
[source, peg]
----
main = hi
hi   = "Hello world"
----

Or conditions `/`

.Or
[source, peg]
----
main = "hello" / "hi"
----

[NOTE]
Indentation sensitive

.Or multiline
[source, peg]
----
main
    = "hello"
    / "hi"
    / "hola"
----

.Or multiline 2
[source, peg]
----
main = "hello"
     / "hi"
     / "hola"
----


.Or disorganized
[source, peg]
----
main = "hello"
     / "hi" / "hola"
----


.Parenthesis
[source, peg]
----
main = ("hello" / "hi")  " world"
----


Just multiline

.Multiline1
[source, peg]
----
main
    = ("hello" / "hi")  " world"
----

.Multiline2
[source, peg]
----
main
    = ("hello" / "hi")
    " world"
----

.Multiline3
[source, peg]
----
main = ("hello" / "hi")
     " world"
----


It is recomended to use or operator `/` on each new line and `=` on first line, like


.Multiline organized
[source, peg]
----
main = ("hello" / "hi")  " world"
     / "bye"
----

.One optional
[source, peg]
----
main = ("hello" / "hi")  " world"?
----


.Repetitions
[source, peg]
----
main         = one_or_more_a / zero_or_many_b
one_or_more  = "a"+
zero_or_many = "b"*
----

Negation will not move current possition

Next example will consume all chars till get an "a"

.Negation
[source, peg]
----
main = (!"a" .)* "a"
----

.Consume till
[source, peg]
----
comment = "//" (!"\n" .)*
        / "/*" (!"*/" .)* "*/"
----

Match a set of chars.
Chars can be defined by range.


.Match chars
[source, peg]
----
number  = digit+ ("." digit+)?
digit   = [0-9]
a_or_b  = [ab]
id      = [_a-zA-Z][_a-zA-Z0-9]*
a_or_b_or_digit  = [ab0-9]
----


Simple recursion

.one or more "a" recursive
[source, peg]
----
as  = "a" as
    / "a"

//  simplified with `+`
ak = "a"+
----



Recursion to match parenthesis

.Recursion match par
[source, peg]
----
match_par = "(" match_par ")"
          / "(" ")"
----




Grammar pending...


=== Text

Hey, I'm a text parser, I need a text to parse ;-P

If you want to parse text indentation sensitive, I recomend you the lib
https://github.com/jleahred/indentation_flattener[indentation_flattener]

In fact, as you saw before, I work with a grammar indented sensitive and I use this library.

The only consideration about the text to parse, is the type. It's not a generic String, it has to be
a more concrete `Text2Parse`

[source, rust]
----
#[derive(Debug, PartialEq, Default)]
pub struct Text2Parse(pub String);
----



== Output

AST

pending...



== API

It works with concrete types vs general types (reducing use of types like String, u32 or usize)


Constants::
[source, rust]
----
pending
----


Concrete types::
[source, rust]
----
pending
----


Functions to call::
[source, rust]
----
pending
----



Error type::
[source, rust]
----
pending
----


Thats all


Look into lib.rs


== Examples

You can look into tests.rs.


.Simple example
[source, rust]
----
pending...
----



.Complex example
[source, rust]
----
pending...
----

More examples on tests.rs


== Hacking the code

The grammar is a set of rules

[source, rust]
----
type Rules = HashMap<Symbol, Expression>;
----

A Symbol is just a String
[source, rust]
----
#[derive(Debug, PartialEq, Eq, Hash, Default, Clone)]
pub struct Symbol(pub String);
----


An expression can be one of...

[source, rust]
----
#[derive(Debug)]
pub enum Expression {
    Simple(Atom),
    Or(MultiExpr),
    And(MultiExpr),
    Not(Box<Expression>),
    Repeat(Box<Expression>, NRep, Option<NRep>), //  min max
}
----

An atom can be just...

[source, rust]
----
#[derive(Debug, PartialEq)]
pub enum Atom {
    Literal(String),
    Match(String, Vec<(char, char)>),
    Dot,
    Symbol(String),
    Nothing,
}
----


[source, rust]
----
----

=== A grammar for the grammar

A grammar to define the grammar to be parsed by de parser. ;-P

I will define the grammar using the this parser grammar definition rules.


[source, peg]
----
grammar = rule+

rule    = symbol  _  "="  _>   expr  _EI?

_> = _  /  _BI
_BI = "\u{02}"      //  begin indentation
_EI = "\u{03}"      //  end indentation
_   = " "*
----

As you can see, indentation is admited but not exaustively checked.

The library https://github.com/jleahred/indentation_flattener[indentation_flattener]
will check and produce valid text.

Here we relax the verification to keep the grammar as simple as possible.

A grammar is a set of rules, where a rule is the symbol name followed by an expression.

About the expression.

As you know, it's important to accept valid inputs, but also it's important to 
build an AST with proper pritority.

Next grammar:

[source, peg]
----
main    =  "A" "B"  /  "B" "C"
----

It's equivalent to:

[source, peg]
----
main    =  ("A" "B")  /  ("B" "C")
----


And not to:

[source, peg]
----
main    =  (("A" "B")  /  "B") "C"
----

To represent this priority, the expression rule has to be defined in a descendant
priority way:


[source, peg]
----
expr            =   or_expr

or_expr         =   and_expr     ("/"  or_expr)*

and_expr        =   compl_expr   (" "  and_expr)*

compl_expr      =   "!" simpl_par
                /   simpl_par ("*" / "+")

simpl_par       =   (simple / parenth_expr)


parenth_expr    =   "("  expr ")"
simple          =   atom
----

Descendant definition

[horizontal]
simpl_par::     It's an atom or a parenthesis experssion

compl_expr::    Complete expresssion. It's a full subtree expression +
                It can have negation or (zero or more or one or more)

and_expr::      Sequence of expressions separated by space

or_expr::       Sequence of expression separated by "/"


Now, it's the `atom` turn:

[source, peg]
----
atom    =   literal
        /   match
        /   dot
        /   symbol

literal =   "\""  (!"\"" .)*  "\""
match   =   "["  ((.  "-"  .)  /  (.))+   "]"
dot     =   "."
symbol  =   [a-zA-Z0-9_]+
----


Hey, what about comments?

What about non significative spaces and carry return?

It will be defined on "_" symbol


[source, peg]
----
grammar         =   rule+

rule            =   symbol  _  "="  _>   expr  _EI?

expr            =   or_expr

or_expr         =   and_expr    (_ "/"  _  or_expr)*

and_expr        =   compl_expr  (  " "  _  and_expr)*

compl_expr      =   "!" simpl_par
                /   simpl_par ("*" / "+")?

simpl_par       =   (simple / parenth_expr)


parenth_expr    =   "("  _  expr  _  ")"
simple          =   atom



atom    =   literal
        /   match
        /   dot
        /   symbol

literal =   "\""  (!"\"" .)*  "\""
match   =   "["  ((.  "-"  .)  /  (.))+   "]"
dot     =   "."
symbol  =   [a-zA-Z0-9_]+


_>  = _  /  _BI
_BI = "\u{02}"      //  begin indentation
_EI = "\u{03}"      //  end indentation

_   =  (" " 
    /   "\n"
    /   comment)*

comment =  "//" (!"/n" .) "/n"
        /  "/*" (!"*/" .) "*/"
----