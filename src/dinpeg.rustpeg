pub parse -> ()
    = _ rule+

rule -> ()
    = symbol  _  "="  _  expr_or+
    / symbol  BEGIN_IND _  "="  _  expr_or+  _ END_INDENT

symbol = [A-Za-z0-9_]+

expr_or -> ()
  = expr_seq+  _ "/" _ expr_seq+
  / expr_seq


expr_seq -> ()
  = expr_par+ (" " / eol)+ expr_par+
  / expr_par


expr_par -> ()
  =  "(" _ expr_or+ _ ")"  modif?
  /  element               modif?


element -> ()
  = literal
  / match
  / dot
  / symbol


literal -> ()
  = "\""  $(!"\"" .)*  "\""

match -> ()
  = "[" (!"\]" .)* "]"

dot -> ()
  = "."


modif -> ()
  = "?"
  / "+"
  / "*"



/*
    =  _ s:sum _    {s}
    /  _ e:sexpr _  {e}     //  signed expresion  +1-2

//  signed expressions
//  trick on  e:sexpr?
sexpr -> f64
    =   _ s:sign v:(par / atom) _  "*" _  r:fact  e:sexpr?  { s*v * r + e.unwrap_or(0.0)}
    /   _ s:sign v:(par / atom) _  "/" _  r:fact  e:sexpr?  { s*v / r + e.unwrap_or(0.0)}
    /   _ s:sign v:(par / atom) _  "+" _  r:sum             { s*v + r }
    /   _ s:sign v:(par / atom) _  "-" _  r:sum             { s*v - r }
    /   _ s:sign v:(par / atom)                             { s*v     }


*/


BEGIN_IND = "\u{2}"
END_INDENT = "\u{3}"

//  ------------------------------------------------------------
//  spaces and comments
_ = #quiet<(whitespace / eol / comment)*>

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
  = "//" (!eolChar .)*
  // / "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

eolChar
  = [\n\r\u{2028}\u{2029}]

/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed
//  spaces and comments
//  ------------------------------------------------------------
